---
title: 'Sharing Secrets Securely: A GPG Solution'
pubDate: 2024-12-15
description: 'How to share production OAuth secrets without LastPass using GPG public-key cryptography.'
author: 'Alex Leye'
tags: ["security", "cryptography", "oauth"]
---
## Contents

## The Problem

Last week, my tech-savvy architect wanted access to a production OAuth client secret for debugging a data integrity issue. Simple enough, right? Wrong. The secret was stored in LastPass, and he didn't have access to our team's shared vault.

**Teams Chat - 2:34 AM**

**Architect**: "Psst.. Alex. Hey Alex. I really need that OAuth secret for debugging. Can you just paste it in the chat?"

**Me**: "The production secret? The top secret customer access secret? I can't just send it over Teams."

**Architect**: "Come on, it's just us in this channel. Who's going to see it?"

**Me**: "The entire company? IT logs? Future me who forgets to delete the message?"

**Architect**: "Just delete it after I copy it. No one will know."

**Me**: "Except the person who screenshots it. And the person who forwards it. And the person who...

Ok fine. Maybe it wasn't 2 AM, but you get the point. Send the plaintext password and have the SREs come for my first-born? Surely there is a more secure way...

## The Solutions That Weren't

My first instinct was to just give him LastPass access, but that would take days to get approved and set up. We needed the secret *now*. 

I briefly considered other options:
- Encrypted zip files (but how do you share the password securely?)
- Temporary shared drives (still leaves the secret exposed)

None of these felt right for a production secret...

<div class="flex justify-center">
  <div class="tenor-gif-embed" data-postid="12907121" data-share-method="host" data-aspect-ratio="1.19205" data-width="300px"><a href="https://tenor.com/view/frodo-keep-your-secrets-alright-then-lotr-gif-12907121">Frodo Keep Your Secrets GIF</a>from <a href="https://tenor.com/search/frodo-gifs">Frodo GIFs</a></div>
</div>
<script type="text/javascript" async src="https://tenor.com/embed.js"></script>

## Enter Public-Key Cryptography

Then it hit me: this is exactly what public-key cryptography was designed for! I could encrypt the secret using his public key, and only he would be able to decrypt it with his private key.

More specifically, as per [Wikipedia](https://en.wikipedia.org/wiki/Public-key_cryptography):

> In an asymmetric key encryption scheme, anyone can encrypt messages using a public key, but only the holder of the paired private key can decrypt such a message. The security of the system depends on the secrecy of the private key, which must not become known to any other.

<div class="flex justify-center">
  <img src="/public_key_encryption.svg" alt="Public-key cryptography" width="300" />
</div>
<div class="flex justify-center">
<p class="text-center text-sm text-gray-600 mt-2">
  By <a href="//commons.wikimedia.org/wiki/User:Davidgothberg" title="User:Davidgothberg">Davidgothberg</a> - <span class="int-own-work" lang="en">Own work</span>, Public Domain, <a href="https://commons.wikimedia.org/w/index.php?curid=1028460">Link</a>
</p>
</div>

In this example of asymmetric key encryption, Bob uses Alice's public key to encrypt a message, and only Alice can decrypt it with her private key. So long as no private key is leaked, the message is secure.

Great, so how do we do this?

## OpenSSL vs GPG

I initially considered using OpenSSL since it's ubiquitous:

```bash
# Encrypt with OpenSSL
openssl rsautl -encrypt -pubin -inkey recipient_public.pem -in secret.txt -out secret.enc

# Decrypt with OpenSSL  
openssl rsautl -decrypt -inkey recipient_private.pem -in secret.enc
```

### OpenSSL Command Breakdown

Let's break down what each argument does:

**Encryption command:**
- `openssl rsautl` - The RSA utility for low-level RSA operations
- `-encrypt` - Specifies encryption mode
- `-pubin` - Indicates the input key is a public key (required for encryption)
- `-inkey recipient_public.pem` - Specifies the public key file to use
- `-in secret.txt` - The plaintext file to encrypt
- `-out secret.enc` - The output encrypted file

**Decryption command:**
- `openssl rsautl` - Same RSA utility
- `-decrypt` - Specifies decryption mode
- `-inkey recipient_private.pem` - Specifies the private key file (kept secret!)
- `-in secret.enc` - The encrypted file to decrypt
- Output goes to stdout by default (can add `-out decrypted.txt` if needed)


Although in my case, OpenSSL was feeling a bit clunky. I had previously run into version mismatch issues the other day when trying to use it to decrypt a file. We'd need to exchange public keys in PEM format, and the commands aren't particularly user-friendly.

## GPG: Keeping it real

GPG (GNU Privacy Guard) turned out to be a great fit for this scenario. As a fan of GNU tools, I appreciate that GPG embodies the free software philosophy - it's designed by and for users, not corporate interests. While OpenSSL is also open source, GPG feels more purpose-built for exactly this use case: secure communication between people, with user-friendly key management built right in.

Oh and GNU is not Unix, btw.

### The Process

**Step 1: Export the recipient's public key**
```bash
# My architect exports his public key
gpg --export --armor john.doe@company.com > john_public.asc
```

**Step 2: Import and encrypt**
```bash
# I import his public key
gpg --import john_public.asc

# Encrypt the secret
echo "oauth_top_secret_super_secret" | gpg --encrypt --armor --recipient john.doe@company.com > secret.asc
```

**Step 3: Share and decrypt**
```bash
# He decrypts the secret
gpg --decrypt secret.asc
```

### GPG Command Breakdown

Let's go over the arguments:

**Step 1 - Exporting the public key:**
- `gpg --export` - Exports a key from the local keyring
- `--armor` - Outputs the key in ASCII format (human-readable) instead of binary
- `john.doe@company.com` - The email address identifying which key to export
- `> john_public.asc` - Redirects output to a file with `.asc` extension (ASCII format)

**Step 2a - Importing the public key:**
- `gpg --import` - Imports a key into your local keyring
- `john_public.asc` - The ASCII-formatted public key file

**Step 2b - Encrypting the secret:**
- `gpg --encrypt` - Specifies encryption mode
- `--armor` - Outputs encrypted data in ASCII format (easier to share via text)
- `--recipient john.doe@company.com` - Specifies who can decrypt (uses their public key)

**Step 3 - Decrypting the secret:**
- `gpg --decrypt` - Specifies decryption mode (simple!)

## "Ok, so...?"

Within a few minutes, we had securely shared the production secret. No LastPass delays, no security compromises, and no plaintext secrets sitting in chat logs.

<div class="flex justify-center">
<div class="tenor-gif-embed" data-postid="25339857" data-share-method="host" data-aspect-ratio="1" data-width="300px"><a href="https://tenor.com/view/michael-scott-secrets-tell-each-other-gif-25339857">Michael Scott GIF</a>from <a href="https://tenor.com/search/michael-gifs">Michael GIFs</a></div>
</div>

The good news too is that now I have his public key, there is 0 overhead to encrypt other secrets across as well. 
